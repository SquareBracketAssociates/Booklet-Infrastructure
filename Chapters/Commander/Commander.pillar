!! Commander: A command pattern library

In this chapter you will learn about a new library to manage commands. The library is based on three main objects: ''commands'' that represent the actions to be executed, ''command activation strategies'' that represent ways commands are activated (e.g. using shortcuts, menus) and ''contexts'' which represent the state of the application, users of commands.

!!! Commands

Commander models application actions as first class objects following the Command design pattern.
Every action is implemented as a separate command class (subclass of ==CmdCommand==) with an ==execute== method and all state required for execution.

!!! Contact Book Example

Let's look at how we can apply commands to control a simple book of contacts.
The code of example is packaged in the ==Commander-Examples== package, so
you can load it and play along. If the package is not present in your
system, load it using:

[[[
Metacello new
	baseline: 'Commander';
	repository: 'github://dionisiydk/Commander';
	load: #'Commander-Examples'.
]]]

Notice that all classes of the example has ==Cmd== prefix, so there is ""no"" conflict with the tutorial in this section. The implemented example represents a final version that is more complex than what is needed at the beggining. We recommend you to follow the tutorial and then compare it with the existing source code. Finally, the tutorial require Pharo version 7, as it depends on a Spec presenter class, that does not exist in previous Pharo versions.

Let's start with the domain implementation. In our domain, we need two classes: one for the contact, and one for the contact book.

!!!! 1. Contact with name and phone

[[[
Object subclass: #Contact
	instanceVariableNames: 'name phone'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

[[[
Contact >> printOn: aStream
	super printOn: aStream.

	aStream nextPut: $(.
	aStream nextPutAll: name.
	aStream nextPut: $).

Contact class >> named: aString phone: aString2
	^ self new
		name: aString;
		phone: aString2;
		yourself
]]]

Also add the ==name== and ==phone== instance variable accessors.

!!!! 2. Contact Book: A Collection Of Contacts

[[[
Object subclass: #ContactBook
	instanceVariableNames: 'contents'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

[[[
ContactBook >> initialize
	super initialize.
	contents := OrderedCollection new.

ContactBook >> addContact: aContact
	contents add: aContact

ContactBook >> add: contactName phone: phone
	| contact |
	contact := CmdContact named: contactName phone: phone.
	self addContact: contact.
	^contact

ContactBook >> includesContact: aContact
	^ contents includes: aContact
]]]

!!!! 3. Rename Contact Command

Now we can create ==RenameContactCommand== to rename given contact

[[[
CmdCommand subclass: #RenameContactCommand
	instanceVariableNames: 'contact newName'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

[[[
RenameContactCommand >> execute
	contact name: newName
]]]

Add the ==contact== and ==newName== instance variable accessors. We use them in the following method:

[[[
RenameContactCommand class >> contact: aContact to: newNameString
	^self new
			contact: aContact;
			newName: newNameString;
			yourself
]]]

Let's try in Playground, we are able to rename a contact using this command:

[[[
| contact command |
contact := Contact new.
command := RenameContactCommand contact: contact to: 'John Smith'.
command execute.
contact name.
]]]

!!! Adding a simple UI

Before we continue, we should write a simple UI which will show the contact book's contents.
This example uses the Spec UI framework. The Spec documentation is available at *http://books.pharo.org*.

We need just one presenter which will show a contact table.

[[[
ComposablePresenter subclass: #ContactBookPresenter
	instanceVariableNames: 'table contactBook'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

[[[
ContactBookPresenter >> setModelBeforeInitialization: aDomainObject
	contactBook := aDomainObject

ContactBookPresenter >> initializeWidgets
	table := self newList.
	table numberOfColumns: 2 withWidths: #(250 250).
	table displayBlock: [ :contact | {contact name. contact phone} ].
	table items: contactBook contents.

ContactBookPresenter class >> defaultSpec
	^ SpecLayout composed
		newColumn: [ :c | c add: #table ];
		yourself
]]]

Add ==table== and ==contactBook== instance variable accessors and define a reusable book as a class side variable.

[[[
ContactBook class >> family
	^family ifNil: [
		family := self new
			add: 'John' phone: '342 345';
			add: 'Bill' phone: '123 678';
			add: 'Mary' phone: '789 567';
			yourself ]
]]]

Now we are able to show a family phone book with our Spec UI:

[[[
ContactBookPresenter class >> familyExample
	<example>
	^ (self on: ContactBook family) openWithSpec
]]]

Note that we declared it as an example with the ==<example>== annotation. This makes it runnable from the browser with a clickable icon.

%+Family book window.>file://Figures/Family.png+
%+Family book window.>file://figures/Family.png|label=Family+

!!! Activation strategy

Commands are reusable objects and applications provide various ways to access them: shortcuts, context menus, buttons, etc.
This information is attached to command classes as activation strategies. Currently there are three types of activations:
- ==CmdShortcutCommandActivation==
- ==CmdContextMenuCommandActivation==
- ==CmdDragAndDropCommandActivation==

Strategies annotate a command as contextual class annotations. Look at the project ClassAnnotation for details *https://github.com/dionisiydk/ClassAnnotation*.

Strategies are always attached to commands via a concrete application context where they can be used.
In the simplest case, it can be just a class of user application or widget like the class ==ContactBookPresenter==.

For example, the following method allows an instance of ==RenameContactCommand== to be executed by shortcut in the context of our presenter:

[[[
RenameContactCommand class >> shortcutActivation
	<classAnnotation>
	^ CmdShortcutCommandActivation by: $r meta for: ContactBookPresenter
]]]

Similarly the following method, ==contextMenuActivation==, allows the ==RenameContactCommand== to be executed from a context menu. Note the use of ==CmdContextMenuCommandActivation== in the method, while the previous one was using ==CmdShortcutCommandActivation==.

[[[
RenameContactCommand class >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemFor: ContactBookPresenter
]]]

If you execute again the family example of  ==ContactBookPresenter==
class, you will notice that the commands do not work yet. The context
menu is not displayed, neither the shortcut works. We first need to
set up the presenter.

!!!! Set Up The Presenter

At the moment, when you open a window neither shortcuts or the context menu will work. The problem is that Spec has no information about Commander. Spec only provides basic functionality to define a menu and shortcuts on a low level. We must manually activate Commander in your Spec presenter.

Modify the ==initializeWidgets== method to activate context menu:

[[[
ContactBookPresenter >> initializeWidgets
	table := self newList.
	table numberOfColumns: 2 withWidths: #(250 250).
	table displayBlock: [ :contact | {contact name . contact phone} ].
	table items: contactBook contents.
	table enableCommanderMenuBy: self.
]]]

The ==enableCommanderMenuBy:== method adds a context menu to the table presenter which will be filled by commands defined in the context of the presenter argument (a ==ContactBookPresenter==).

In this case, right clicking on the table will show the menu with a single item named ==RenameContactCommand==.
To specify a better name for the menu item, you need to define the method ==defaultMenuItemName==:

[[[
RenameContactCommand >> defaultMenuItemName
	^'Rename'
]]]

Notice that the shortcut does not work yet. We will fix it later in this section.

!!! Getting the information from the user

Now, if you click on the 'Rename' menu item, you will get an exception. From the debugger you can investigate that the command instance is not initialized: ==contact== and ==newName== are nil.
Commander provides a method where a command should retrieve the required state from the given context instance:

[[[
RenameContactCommand >> prepareFullExecutionInContext: aToolContext
	super prepareFullExecutionInContext: aToolContext.

	contact := aToolContext selectedContact.

	newName := UIManager default
		request: 'New name of the contact'
		initialAnswer: contact name
		title: 'Rename a contact'.
	newName isEmptyOrNil | (newName = contact name) ifTrue: [ ^ CmdCommandAborted signal ]
]]]

By default (with the help of Spec integration) Commander will pass a presenter instance as the argument (aToolContext). But in general it is not enough and you will see example later.

For now, you only need to know that a context represents application state and that in the ==prepare==â€¦ method we define the information required to be able to reuse commands in various applications.

In our example, we expect to receive ==selectedContact== from the context and we request a ==newName== directly from the user.
Note that Commander provides hook to customize preparation for different application contexts. By default it is ==prepareFullExecutionInContext:== but advanced scenarios may require a different approach.

Now we need presenter to respond to ==selectedContact== to make it compatible to the context of our command:

[[[
ContactBookPresenter >> selectedContact
	^ table selectedItem
]]]

If you now click on the 'Rename' item, you will be prompted for a new contact name. However, after submitting, the view will be not updated. To see the result for now, reopen presenter window.

!!!! Refreshing the view

It is your responsibility to manage updates between the application and model. You can use some event mechanism which will automatically update the view after modification of the model.

But Commander provides a very simple way to apply the result of a command which can be also used to update the view. The ==applyResultInContext:== method is called when the command is executed. You can implement it on your commands to produce the desired effect in the context of your application:

[[[
RenameContactCommand>>applyResultInContext: aToolContext
	super applyResultInContext: aToolContext.

	aToolContext updateView
]]]

Here we require that the context should be able update the view, so our presenter should support it:

[[[
ContactBookPresenter >> updateView
	table items: contactBook contents
]]]

Now the context menu is working as we would expect: it asks for a new name and updates the table with the result.

!!!! Enabling Shortcuts

Now we can enable shortcuts on the presenter. Just implement the method ==ensureKeyBindingsFor:==:

[[[
ContactBookPresenter >> ensureKeyBindingsFor: aWidget
	self enableCommanderShortcutsIn: aWidget
]]]

Then reopen the window, select a contact and press ==cmd+r== (on Mac). You will get same the UI dialog as in the case of the menu.

!!! More Commands

Finally, let's try to create a few other commands. Since the presenter's infrasturcture has already been set up, the creation of new commands is a very straightforward process:

!!!! 1. Modify Phone Number Command

[[[
CmdCommand subclass: #ChangePhoneCommand
	instanceVariableNames: 'contact newPhone'
	classVariableNames: ''
	package: 'Commander-Examples'

ChangePhoneCommand >> execute
	contact phone: newPhone

ChangePhoneCommand >> prepareFullExecutionInContext: aToolContext
	super prepareFullExecutionInContext: aToolContext.

	contact := aToolContext selectedContact.

	newPhone := UIManager default
		request: 'New phone for the contact'
		initialAnswer: contact phone
		title: 'Set new phone for contact'.
	newPhone isEmptyOrNil | (newPhone = contact name) ifTrue: [ ^ CmdCommandAborted signal ]

ChangePhoneCommand >> applyResultInContext: aToolContext
	super applyResultInContext: aToolContext.

	aToolContext updateView

ChangePhoneCommand >> defaultMenuItemName
	^'New phone'
]]]

Activation methods:

[[[
ChangePhoneCommand class >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemFor: ContactBookPresenter

ChangePhoneCommand class >> shortcutActivation
	<classAnnotation>
	^CmdShortcutCommandActivation by: $p meta for: ContactBookPresenter
]]]

!!!! 2. Remove Contact Command

[[[
CmdCommand subclass: #RemoveContactCommand
	instanceVariableNames: 'contactBook contact'
	classVariableNames: ''
	package: 'Commander-Examples'

RemoveContactCommand >> execute
	contactBook removeContact: contact

RemoveContactCommand >> prepareFullExecutionInContext: aToolContext
	super prepareFullExecutionInContext: aToolContext.

	contactBook := aToolContext selectedContactBook.
	contact := aToolContext selectedContact.

RemoveContactCommand >> applyResultInContext: aToolContext
	super applyResultInContext: aToolContext.

	aToolContext updateView

RemoveContactCommand >> defaultMenuItemName
	^'Remove'
]]]

Here we must extend the context a bit. To be able remove a contact, we will need a contact book instance from which the contact should be deleted.

Therefore, we will implement a new method - ==selectedContactBook== - in the presenter:

[[[
ContactBookPresenter >> selectedContactBook
	^contactBook
]]]

Notice that in our ==prepare== method, we ''could'' send the ==contactBook== accessor to aToolContext. Unfortunately, it limits reusability of our command because the name ==contactBook== assumes that there is only a single book instance while other applications might provide multiple contact books.
So it is better to send the ==selectedContactBook== method because it better reflects the abstract requirement of the information: we expect that there will be a selected book in the context of the command activation.

Finally, we need to implement the ==removeContact:== method:

[[[
ContactBook >> removeContact: aContact
	contents remove: aContact ifAbsent: nil
]]]

and activation methods:

[[[
RemoveContactCommand class >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemFor: ContactBookPresenter

RemoveContactCommand class >> shortcutActivation
	<classAnnotation>
	^CmdShortcutCommandActivation by: $x meta for: ContactBookPresenter
]]]

!!!! 3. Command to add contact:

[[[
CmdCommand subclass: #AddContactCommand
	instanceVariableNames: 'contactBook contact'
	classVariableNames: ''
	package: 'Commander-Examples'

AddContactCommand >> execute
	contactBook addContact: contact

AddContactCommand >> prepareFullExecutionInContext: aToolContext
	| nameAndPhone pair |
	super prepareFullExecutionInContext: aToolContext.
	contactBook := aToolContext selectedContactBook.

	nameAndPhone := UIManager default
		request: 'Enter new contact name and phone (split by semicolon)'
		initialAnswer: 'name;phone'
		title: 'Create new contact'.
	nameAndPhone isEmptyOrNil ifTrue: [ ^ CmdCommandAborted signal ].
	pair := (';' split: nameAndPhone).
	contact := CmdContact named: pair first phone: pair last

AddContactCommand >> applyResultInContext: aToolContext
	super applyResultInContext: aToolContext.

	aToolContext updateView

AddContactCommand >> defaultMenuItemName
	^'New contact'
]]]

Above, we request the required information from the user: both a name and phone number in a semicolon separated form.

Activation methods:

[[[
AddContactCommand class >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemFor: ContactBookPresenter

AddContactCommand class >> shortcutActivation
	<classAnnotation>
	^CmdShortcutCommandActivation by: $n meta for: ContactBookPresenter
]]]

%+Family book menu>file://figures/FamilyMenuDefault.png+

As you create more commands, pay attention for refactoring opportunities. For example, our commands in this tutorial duplicate both state (==contact==) and behavior (==applyResultInContext:==). As an exercise, refactor to your taste by extracting a common superclass and so on.

@@todo Stef here

!!! Extra command conditions

Currently, there will be error if you try to rename a contact when no item is selected in the table.

Normally the menu should not include items in such cases or they should be disabled.

To define the runtime conditions of command activation you need a class side method ==canBeExecutedInContext:==:

[[[
RenameContactCommand class>>canBeExecutedInContext: aToolContext
	^aToolContext isContactSelected
]]]

(The default implementation allows any command to be executed in any context by always returning true)

And the presenter should implement ==isContactSelected==:
[[[
ContactBookPresenter>>isContactSelected
	^table selectedItem notNil
]]]

!!! Context menu tuning

We already redefine menu item name in the method ==defaultMenuItemName==.

There are other options:
- order of item in menu
- submenu
- separator between items
- menu icon
- menu item tooltip
- custom menu item

!!!! Menu item order

In our example 'Rename' item was placed at the end of menu because by default items are sorted in alphabetical order.

To change the order the activation strategy should be created with extra parameter:

[[[
RenameContactCommand >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byRootGroupItemOrder: 1 for: ContactBookPresenter
]]]

The lesser order value puts item to the top of menu list.

%+Context menu reordered>file://Figures/FamilyMenuRenameFirst.png+

!!!! Submenu

Commander allows create hierarchical menu using reified menu groups.
Imaging that you want put 'New phone' command under 'Phone operations' submenu.

First you need new subclass of ==CmdMenuGroup== class:

[[[
CmdMenuGroup subclass: #PhoneMenuGroup
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

And then add this class as extra parameter to the menu activation strategy:

[[[
ChangePhoneCommand >> contextMenuActivation
	<classAnnotation>
	^CmdContextMenuCommandActivation byItemOf: PhoneMenuGroup for: ContactBookPresenter
]]]

It will moves ChangePhoneCommand to extra submenu with name 'PhoneMenuGroup'. You can specify better name as in case of commands:

[[[
PhoneMenuGroup>>name
	^'Phone operations'
]]]

%+Submenu>file://Figures/FamilyMenuPhoneGroup.png+

If you need deep menu structure just define class side method ==parentGroup== in your very child group:

[[[
DeepChildrenMenuGroup class>>parentGroup
	^PhoneMenuGroup
]]]

!!!! Menu separators

Commander uses separators to represent inlined menu groups.

If group is marked as inlined then all items are added to the parent group with required separator lines. To inline group you need override ==isInlined== method:

[[[
PhoneMenuGroup>>isInlined
	^true
]]]

%+Inlined menu>file://Figures/FamilyMenuInlined.png+

!!!! Menu icons

To specify simple icon the command should implement class side method ==defaultMenuIconName==. For example we can add icon to the ==RemoveContactCommand==:

[[[
RemoveContactCommand class>>defaultMenuIconName
	^#removeIcon
]]]

%+Iconic menu item>file://Figures/FamilyMenuWithIcon.png+

If you need complex icon which depends on command state you should implement instance side method #defaultMenuIcon.
For example following method will add random icon for into menu item:

[[[
RemoveContactCommand>>defaultMenuIcon
	^Smalltalk ui icons icons atRandom
]]]

!!!! Menu item tooltip

To specify tooltip for menu item just define method ==description== on instance side of command or group:

[[[
RemoveContactCommand>>description
   ^'Remove selected contant from book'
]]]

!!!! Custom menu items

When Commander builds context menu it asks command itself to build view (a morph) for menu item.
By default CmdCommand builds standard menu item morph but subclasses can redefine it to be represented specifically.

For example we can represent item with different color:

[[[
RenameContactCommand>>fillContextMenu: aMenu using: aCommandActivator
	| item |
	item := aMenu
		add: aCommandActivator menuItemName
		target: aCommandActivator
		selector: #executeCommand.

	item color: Color red
]]]

%+Custom menu item>file://Figures/FamilyMenuWithCustomItem.png+

You can notice here that command can be represented by multiple menu items. The ==fillContextMenu:using:== method provides full control under menu.
For example you can generate multiple command copies with some specific parameters. It allows dynamic menus which can be needed in some cases.

Also same kind of flexibility is available for groups. Look at default implementation of menu group for example:

[[[
CmdMenuGroup>>buildContextSubMenuIn: aMenu
	| submenu |
	submenu := UIManager default newMenuIn: aMenu defaultTarget for: aMenu defaultTarget.

	contents do: [ :each | each buildContextMenu: submenu ].

	submenu hasItems ifTrue: [ aMenu add: self name subMenu: submenu]
]]]

You can redefine it in your own group to build very special menus.

!!! Drag and drop example

In this section you will learn how activate commands using drag and drop operation.

During drag and drop operation user grabs some element from one widget and drops it on another widget. And the application handles special event which brings together the information about source and target elements.

Commander uses drag and drop to prepare commands in two steps:
1) When a user starts to drag an element from a widget, Commander finds and prepares commands in the context of this widget and dragged element. Found commands are then used as passengers of the drag operation.
2) When the user drops element to a widget, Commander selects a corresponding command among the dragged commands that fits to the declared drop context and the context of the target widget. Commander then executes the selected command.

If Commander does not find any command in the drag context, the drag and drop operation is not started.

If Commander does not find any command suitable for the drop context, it forbids drop on the current widget. UI gives visual feedback for the places where the drop can be executed. And when the drop is forbidden you will not see this effect.

If Commander finds multiple commands suitable for the drop context it will show menu to request user to choose one.

Now we can annotate existing command ==AddContactCommand== with drag and drop activation:

[[[
AddContactCommand class >> dragAndDropActivation
	<classAnnotation>
	^CmdDragAndDropCommandActivation for: ContactBookPresenter toDropIn: ContactBookPresenter
]]]

First parameter describes context where drag can be started. And last parameter is a context where drop can be executed. In the example above, both contexts are the same presenter which enables drag and drop contacts between contact books.

As in example with context menu and shortcuts we also need activate Commander based drag and drop in our presenter. It should be enabled in ==initializeWidgets== method:

[[[
ContactBookPresenter >> initializeWidgets
	table := self newList.
	table numberOfColumns: 2 withWidths: #(250 250).
	table displayBlock: [ :contact | {contact name. contact phone} ].
	table items: contactBook contents.
	table enableCommanderMenuBy: self.

	table enableCommanderDragAndDropBy: self.
]]]

==enableCommanderDragAndDropBy:== activates drag of items from the table using commands from presenter in the argument (which is ==ContactBookPresenter==). And it activates drop to the table with commands defined in the drop context of presenter in the argument (which is ==ContactBookPresenter==).

There are separate ==enableCommanderDragBy:== and ==enableCommanderDropBy:== methods which allow activate drag and drop separatelly with different comand contexts.

To prepare command instance in two steps we need implement two methods:

[[[
AddContactCommand >> prepareExecutionInDragContext: aToolContext
	super prepareExecutionInDragContext: aToolContext.

	contact := aToolContext selectedContact
]]]

The ==prepareExecutionInDragContext:== method extracts information from the context of drag operation. In that case we decided that command can be only executed by drag of ==selectedContact==.

[[[
AddContactCommand >> prepareExecutionInDropContext: aToolContext
	super prepareExecutionInDropContext: aToolContext.

	contactBook := aToolContext selectedContactBook
]]]

And in the second method ==prepareExecutionInDropContext:== we extract the rest information from the context where the drop was executed. In that case, we decided that command can be only executed by drop into the ==selectedContactBook==.

To be able to update the view, you can implement the method:

[[[
AddContactCommand >> applyDropResultInContext: aToolContext
	super applyDropResultInContext: aToolContext.
	aToolContext updateView.
]]]

As we mentioned before, the model, ==Contact== and ==ContactBook== should notify state changes. We leave this code improvement to the reader.

The drag and drop feature should finally work. To play with it let's create another book of co-workers on the class side of ==ContactBook==:

[[[
ContactBook class >> coworkers
	^coworkers ifNil: [
		coworkers := self new
			add: 'Stef' phone: '112 378';
			add: 'Pavel' phone: '898 678';
			add: 'Marcus' phone: '444 888';
			yourself]
]]]

And we need extra example method on the class side of presenter:

[[[
ContactBookPresenter class >> coworkersExample
	<example>
	^ (self on: CmdContactBook coworkers) openWithSpec
]]]

Now open two windows: ==coworkersExample== and ==familyExample==, and drag and drop contacts between them.

You can notice that you are able dublicate contact when it already exists in the target book. The duplication also happens when you drop contact in same source book.

To prevent it you can specify extra runtime condition ==canBeExecutedInDropContext:== as in case of full command execution:

[[[
AddContactCommand >> canBeExecutedInDropContext: aToolContext
	^aToolContext isContactBookSelected
		and: [ (aToolContext selectedContactBook includesContact: contact) not ]

ContactBookPresenter >> isContactBookSelected
	^ true
]]]

Notice that the ==canBeExecutedInDropContext:== method is on the instance side and it can use the data extracted from the drag context. Here we check that ==contact== does not exist in the target contact book.

When Commander collects commands at the time of drag operation it prepares them using method ==prepareExecutionInDragContext:==. So at the time of the drop operation all found commands are initialized with information from the drag context.

Also notice that here we add extra check ==isContactBookSelected==. We can omit it because in our example contact book always exists in presenter. But for reusability purpose we should implement this method independently from our knowledge about existing context. Imaging that we will have another presenter with table of existing books and we will need to drop contacts to it items. In that case it will be required to check that book is actually selected. Instead we will get error when table has no selection.

So at the end our presenter do not accept drops of contacts which aready exist in the book.

!!! Complex contexts

Until now, the command context was always represented by presenter itself. It is default behavior of the Spec integration with Commander.

Problem with this approach is that the presenter is always bound to its own current state. It is fine for simple cases. However, it is then not possible to activate commands in a context of contact that is not selected in the table. The following example demonstrates problem in live:

You can notice that dropping contact into the book always adds it to the end of list. But drop operation always points to an element in the table. So we can support drop to the particular position.

For this we need to extend ==AddContactCommand== with ==afterContact== variable after which we will add new contact:

[[[
CmdCommand subclass: #AddContactCommand
	instanceVariableNames: 'contactBook afterContact contact'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

And we should modify execution method to take into account new logic. Also we need extra method ==addContact:after:== in ==ContactBook==:

[[[
AddContactCommand>>execute
	afterContact
		ifNil: [ contactBook addContact: contact]
		ifNotNil: [ contactBook addContact: contact after: afterContact ]

ContactBook>>addContact: newContact after: contactBefore
	contents add: newContact after: contactBefore
]]]

So if ==afterContact== is not specified the new contact will be added to the end of list.

We can support this logic in full execution scenario where command is activated from menu or by shortcut:

[[[
AddContactCommand>>prepareFullExecutionInContext: aToolContext
	| nameAndPhone pair |
	super prepareFullExecutionInContext: aToolContext.

	contactBook := aToolContext selectedContactBook.
	aToolContext isContactSelected ifTrue: [
		afterContact := aToolContext selectedContact].

	nameAndPhone := UIManager default
		request: 'Enter new contact name and phone (split by semicolon)'
		initialAnswer: 'name;phone'
		title: 'Create new contact'.
	nameAndPhone isEmptyOrNil ifTrue: [ ^ CmdCommandAborted signal ].
	pair := (';' split: nameAndPhone).
	contact := CmdContact named: pair first phone: pair last
]]]

New contact will be added after selected contact in the context of target presenter (aToolContext is a presenter instance for now). You can test new logic by creating new contacts from the context menu or by the shortcut.

For drag and drop case we should also modify ==prepareExecutionInDropContext:==:

[[[
AddContactCommand>>prepareExecutionInDropContext: aToolContext
	super prepareExecutionInDropContext: aToolContext.

	contactBook := aToolContext selectedContactBook.
	aToolContext isContactSelected ifTrue: [
		afterContact := aToolContext selectedContact].
]]]

Now if you would play with drag and drop you will notice that it works in not expected way: new contact is always added into the target book after selected item instead of the item where drop is executed.

The problem is that the selection of the drop target is the static state of the target book presenter. It could not be different depending on the actual place of drop operation.

This example shows that the simple case where presenter is its own context has limitations. We should finally introduce the real context which will encapsulate selected contact independently of presenter.

Contexts are subclasses of ==CmdToolContext== and they should include all information to describe the state of underlying tool. In our case it will include ==selectedContacts== variable:

[[[
CmdToolContext subclass: #ContactBookPresenterContext
	instanceVariableNames: 'selectedContacts'
	classVariableNames: ''
	package: 'Commander-Examples'
]]]

Commander passes multiple items to the request context from presenter. This is a default behavior of Spec as the selection can include multiple items. For that reason, we should use the contact collection instead of a single item. In addition, context should support all methods which are required by commands:

[[[
ContactBookPresenterContext>>selectedContact
	^selectedContacts last "last selected item"

ContactBookPresenterContext>>isContactSelected
	^selectedContacts notEmpty

ContactBookPresenterContext>>selectedContactBook
	^tool contactBook

ContactBookPresenterContext>>isContactBookSelected
	^true

ContactBookPresenterContext>>updateView
	tool updateView
]]]

Notice that base class of context ==CmdToolContext== provides ==tool== variable which is presenter instance in our case.

Also to implement ==selectedContactBook== we do not need to call ==selectedContactBook== from presenter. It was the message to represent presenter as own context. So ==selectedContactBook== can be removed from presenter together with the ==isContactBookSelected== method because they are now defined by reified context class.
(==ContactBookPresenterContext== tightly bound to the ==ContactBookPresenter==. It knows that contact book is mondatory property of the presenter and it can call the accessor directly.

To inject new context to our presenter we should override two methods:

[[[
ContactBookPresenter>>createCommandContextForSelection: selectedContacts
	^ContactBookPresenterContext for: self of: selectedContacts

ContactBookPresenter>>createCommandContext
	^self createCommandContextForSelection: table selectedItems

ContactBookPresenterContext class>>for: aPresenter of: contacts
	^ (self for: aPresenter) selectedContacts: contacts

ContactBookPresenterContext>>selectedContacts: contacts
	selectedContacts := contacts
]]]

The first method creates concrete context instance with selected items. The second method provides default selection (from the table) to the context.
@@todo Juraj: I do not understand the difference. When they are called/used?

And the last important details are needed:

When we introduced new context the way how Commander lookup commands is changed. By default (in case  of the Spec framework) Commander finds all commands which are annotated with given presenter class using ==isKindOf:==. Nevertheless, in the case with the reified context, Commander scans commands using class of context instead of class of tool.

In general case activation strategies should be attached to commands using class of context instead of tool. The reason why it is implemented like this is that a single application/presenter can provide multiple contexts depending on child component which triggers menu, shortcuts, and so on. The single presenter can have many different menus. Imagine the presenter with two tables where each table provides own menu and shortcuts.

So if we do use the presenter as we do until now, our application will miss all menus and shortcuts. There are two ways how to fix it:

1. Modify all command activations to use context class ==ContactBookPresenterContext== instead of presenter class ==ContactBookPresenter==.

This approach would be required if we would extend our presenter with an extra component which will provide separate set of commands. But in our example we do not need it.

2. Adopt our context to be a simple single context of presenter.

In case when presenter provides single set of commands we can just mark the context as simple. It is preferred solution for simple presenters because in that case internal context implementation will be hidden from users. All commands will mention only presenter class in annotations.

So in simple context the tool (presenter) is actual user of commands. And it should redefine the ==representsSimpleAnnotationUser:== method by testing that the tool is a kind of given class.

In our example we follow this approach:

[[[
ContactBookPresenterContext>>representsSimpleAnnotationUser: aToolClass
	^tool isKindOf: aToolClass
]]]

Now if you will try again drag and drop you will see that drop inserts contact after element where drop is executed.
@@todo Juraj: I do not understand when it happens that the selectedContact is the one I drop on it. Can you summarize it here? What is the different comparing to the situation without the ==ContactBookPresenterContext==?

More details on this part:

==representsSimpleAnnotationUser:== method is part of ClassAnnotation library. When you create annotation using class as context the annotation will be visible only for instances of this class hierarchy. Annotation uses the ==isKindOf:== check to detect that given user can find it. But user can redefine this logic in the method ==representsSimpleAnnotationUser:==.

In case of Commander the user of annotation is a tool context. But there is ==CmdSimpleToolContext== which is default for Spec presenters. It redefines this logic in the way that the tool becomes actual user of annotation. It simply checks that the tool is a kind of declared user class.

So if you implement other simple contexts they should redefine this method in same way as ==CmdSimpleToolContext==. And it is what we did in this example.

(Notice that ==CmdSimpleToolContext== should not be used as superclass for new contexts because it overrides other logic of base ==CmdToolContext== class)

!!! Advanced command activation

All commands in our examples define standard activation methods:

- ==prepareFullExecutionInContext:==
- ==canBeExecutedInContext:==
- ==prepareExecutionInDragContext:==
- ==prepareExecutionInDropContext:==
- ==canBeExecutedInDropContext:==

If you cannot reuse those methods in a specific situation (application), your context (application) should override activation logic and send another set of messages to commands. For example:

[[[
SpecialContextA >> allowsExecutionOf: aCommand
	 ^aCommand canBeExecutedInSpecialContextA: self

SpecialContextA >> prepareFullExecutionOf: aCommand
  aCommand prepareFullExecutionInSpecialContextA: self

SpecialContextA >> applyResultOf: aCommand
  aCommand applyResultInSpecialContextA: self

SpecialContextA >> allowsDropExecutionOf: aCommand
  ^aCommand canBeExecutedInSpecialDropContextA: self

SpecialContextA >> prepareDragActivationOf: aCommand
	aCommand prepareExecutionInSpecialDragContextA: self

SpecialContextA >> prepareDropExecutionOf: aCommand
	aCommand prepareExecutionInSpecialDropContextA: self
]]]

Then application can extend base ==CmdCommand== class with default implementation like:

[[[
CmdCommand >> prepareFullExecutionInSpecialContextA: aSpecialContextA
  self prepareFullExecutionInContext: aSpecialContextA
]]]

And only particular commands will implement them specifically:

[[[
SomeCommand >> prepareFullExecutionInSpecialContextA: aSpecialContextA
  "special logic to prepare command for execution"
]]]

!!! Command lookup and execution

Commands are annotated with activation strategy using context where they can be used.

You can inspect all strategies (and their commands) using ClassAnnotation API:

[[[
CmdShortcutCommandActivation registeredInstances
]]]

It will return all shortcuts in the system.

[[[
CmdContextMenuCommandActivation registeredInstances
]]]

It will return all menu items in the system.

To filter commands for concrete application you need a context instance. For our presenter it would be:

[[[
context := (ContactBookPresenter on: ContactBook family) createCommandContext.
]]]

Then you can query all commands suitable for this context:

[[[
CmdShortcutCommandActivation visibleInstancesInContext: context.
]]]

It returns four shortcuts as we implemented four commands in this section.

And you can filter them to see only active commands:

[[[
CmdShortcutCommandActivation activeInstancesInContext: context.
]]]

It returns single activation because only the add command can be executed without selected item (by default the table selection is empty).

To execute collected commands you should create the command activator instance:

[[[
activator := (CmdShortcutCommandActivation activeInstancesInContext: context) first newActivatorFor: context.
]]]

It encapsulates the given context and performs all required logic to prepare the command for its execution and to apply result after the execution:

[[[
activator executeCommand.
]]]

There is a suitable method to enumerate all commands and to execute them with a prepared activator instance:

[[[
CmdShortcutCommandActivation
	activateAllInContext: context
	by: [:activator | activator executeCommand].
]]]

!!! Menu activation

There is a lot of different menu types: context menu, toolbar, morphic halo menu, etc.
All of them are very similar: they show set of items to a user and when the user selects one, the action associated with item is evaluated. The main difference between them is the way they are displayed to the user.

The commander library allows the building of different kind of menus based on commands and first class groups. Concrete type of menu is represented by concrete type of activation strategy, a subclass of ==CmdMenuCommandActivationStrategy==. The simplest example is ==CmdContextMenuCommandActivation== which we used to define context menu in our presenter example. Now it is only available in Commander. For other examples look at the Calypso browser.

In summary, users annotate commands with menu activations and Commander builds menus using them:

[[[
YourCommand >> yourAppMenuActivation
  <classAnnotation>
  ^ConcreteMenuCommandActivation byItemOf: YourAppChildMenuGroup for: YourAppContext
]]]

The menu activation provides information about name, group and position of command inside menu:
- ==menuItemName== (by default it is retrieved from the command instance by sending the ==defaultMenuItemName== message).
- ==menuItemOrder== (higher value pushes command to the end of menu)
- ==menuGroup== (root by default)

To set up these properties there are few instance creation methods:
- ==byRootGroupItemFor: YourAppContext==
- ==byRootGroupItemOrder: aNumber for: YourAppContext==
- ==byItemOf: menuGroupClass for: YourAppContext==
- ==byItemOf: menuGroupClass order: aNumber for: YourAppContext==

The tree structure of menu is represented by ==CmdMenu== instance. It should be created with concrete class of menu activation. For example for context menu it would be:

[[[
menu := CmdMenu activatedBy: CmdContextMenuCommandActivation.
]]]

And then you can ask it to build items which are active for given context:

[[[
menu buildInContext: context.
]]]

If your application provides multiple contexts, you can call this method for all of them. In that case menu will include items from all widgets which provide these contexts.

For our example you can inspect menu instance after the ==buildInContext:== method execution. You will see ==rootGroup== variable in the inspector where you can reach menu items and underlying commands.

When menu instance is ready you can ask it to create concrete menu object like Morphic context menu:

[[[
(menu buildContextMenuFor: World) openInWorld.
]]]

It is the way how to implement new kind of menus. First, create new subclass of ==CmdMenuCommandActivationStrategy== and then extend ==CmdMenu== with new logic to build required menu objects. You can extend ==CmdCommand== to represent item specifically for your type of menu.

Look for details at package ==Commander-Activators-ContextMenu== which implements classic context menu based on commands.

For example ==CmdContextMenuCommandActivation== implements helper method to create context menu for single application context. So previous example with building menu can be simplified:

[[[
(CmdContextMenuCommandActivation buildMenuFor: World inContext: context) openInWorld
]]]

Context menu extends command with menu building method:

[[[
CmdCommand >> fillContextMenu: aMenu using: anActivator
]]]

It creates menu item morph and allows subclasses to define default label and icon:

- ==defaultMenuItemName==
- ==defaultMenuIcon==.

By default last method uses class side icon name (==defaultMenuIconName==). They both return nil default value.
So for simple icons just default class side method ==defaultMenuIconName==. It will give you the icon from global ==Smalltalk ui icons== registry.

Subclasses can override building method ==fillContextMenu:using:== to represent items differently. For example they can create menu item with check box or decorate them with special colors.

!!! Shortcut activation

As you saw in example section ==CmdShortcutCommandActivation== is used to annotated commands with shortcut:

[[[
RenameContactCommand class >> shortcutActivation
	<classAnnotation>
	^ CmdShortcutCommandActivation by: $r meta for: ContactBookPresenter
]]]

There are extra helper methods for standard shortcuts:
- ==renamingFor:==
- ==removalFor:==

So we can rewrite activation using:

[[[
RenameContactCommand class >> shortcutActivation
	<classAnnotation>
	^ CmdShortcutCommandActivation renamingFor: ContactBookPresenter
]]]

Notice that annotations are cached and cache is updated only when declaration method is changed. It means that you should manually update cache when you modify helper methods like ==renamingFor:==:

[[[
ClassAnnotation resetAll.
]]]

On the low level of Morphic integration the application should define specific kmDispatcher for target morphs:

[[[
YourAppMorph >> kmDispatcher
  ^CmdKMDispatcher attachedTo: self
]]]

with supporting method:

[[[
YourAppMorph >> createCommandContext
  ^YourAppContext for: self
]]]

In the book contact example, we use high level Spec integration where we enable Commander in target presenter:

[[[
ContactBookPresenter >> ensureKeyBindingsFor: aWidget
	self enableCommanderShortcutsIn: aWidget
]]]

Users then do not need to think how morphs are connected in case of Spec.

Other libraries/frameworks can privide similar integration to simplify Commander usage.

!!! Conclusion
